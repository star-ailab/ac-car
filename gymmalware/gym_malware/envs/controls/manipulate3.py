# TODO:
# * modify exports using lief
# * zero out rich header (if it exists) --> requires updating OptionalHeader's checksum ("Rich Header" only in Microsoft-produced executables)
# * tinker with resources: https://lief.quarkslab.com/doc/tutorials/07_pe_resource.html

import lief  # pip install https://github.com/lief-project/LIEF/releases/download/0.7.0/linux_lief-0.7.0_py3.6.tar.gz
import json
import os
import sys
import array
import struct  # byte manipulations
import random
import tempfile
import subprocess
import functools
import signal
import multiprocessing

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, 'small_dll_imports.json'), 'r'))
SECTION_TYPES = [
                           lief.PE.SECTION_TYPES.BSS,
                           lief.PE.SECTION_TYPES.DATA,
                           lief.PE.SECTION_TYPES.EXPORT,
                           # lief.PE.SECTION_TYPES.IDATsA,
                           lief.PE.SECTION_TYPES.RELOCATION,
                           lief.PE.SECTION_TYPES.RESOURCE,
                           lief.PE.SECTION_TYPES.TEXT,
                           lief.PE.SECTION_TYPES.TLS_,
                           lief.PE.SECTION_TYPES.UNKNOWN
                        ]
PARENT = "/".join(os.path.realpath(__file__).replace("\\", "/").split("/")[:-2])

if PARENT == "":
    PARENT = "."

BUILDPATH = PARENT + "/build/"

class MalwareManipulator(object):
    def __init__(self, bytez):
        self.fname = "build.exe"
        self.binary = lief.PE.parse(bytez)
        self.bytez = bytez
        self.min_append_log2 = 5
        self.max_append_log2 = 8

    def __init__(self, filename = ""):
        self.fname = filename.split('/')[-1].split('.')[0]
        self.binary = lief.PE.parse(filename)
        with open(filename,"r+b") as f:
            self.bytez = bytearray(f.read())
        self.min_append_log2 = 5
        self.max_append_log2 = 8

    def __random_length(self):
        return 2**random.randint(self.min_append_log2, self.max_append_log2)

    def __saveBinary(self, binary, dos_stub=False, imports=False, overlay=False, relocations=False, resources=False, tls=False):
        '''
        Originally meant to convert binaries back to bytes, but the original process didnt work
        Added builder.build() so that it actually saves the binary into a file that LIEF can parse
        DOES NOT SAVE TO FILE

        :param binary: New Binary with changes
        :param dos_stub: PE file options
        :param imports: PE file options
        :param overlay: PE file options
        :param relocations: PE file options
        :param resources: PE file options
        :param tls: PE file options
        :return: New Bytes with changes recorded.

        Also saves binary into a file specifies by the buildpath
        '''

        # write the file back as bytez
        builder = lief.PE.Builder(binary)
        builder.build_dos_stub(dos_stub) # rebuild DOS stub

        builder.build_imports(imports) # rebuild IAT in another section
        builder.patch_imports(imports) # patch original import table with trampolines to new import table

        builder.build_overlay(overlay) # rebuild overlay
        builder.build_relocations(relocations) # rebuild relocation table in another section
        builder.build_resources(resources) # rebuild resources in another section
        builder.build_tls(tls) # rebuilt TLS object in another section

        builder.build() # perform the build process

        # builder.write(BUILDPATH + self.fname)

        # try:
        #     self._saveBytes()
        # except:
        #     pass
        return array.array('B', builder.get_build()).tobytes()

    def _saveBytes(self):
        '''
        Saves Bytez variable to file. ONLY FUNCTION IN CODE TO SAVE TO FILE

        :return:
        '''
        with open(BUILDPATH + self.fname, 'w+b') as file:
            file.write(self.bytez)


    def __call__(self, actionList = []):
        '''
        Main action function. Accepts a list of numbers that corresponds to an action

        :param actionList: List of numbers
        :return:
        '''
        # print(actionList)
        actionDict = {
            1 : self.overlay_append,
            2 : self.imports_append,
            3 : self.section_rename,
            4 : self.section_add, #Apparently breaks functionality
            5 : self.section_append,
            6 : self.upx_pack, #Require UPX download
            7 : self.upx_unpack, #Require UPX download
            8 : self.remove_signature,
            9 : self.remove_debug,
            10 : self.break_optional_header_checksum,
            11: 500000,
            12: 1000000,
            13: 1500000,
            20: self.changeTDS
        }

        #Runs all actions sequentially
        for i in actionList:
            if(i==1):
                actionDict[i]()
            elif(i>10 and i < 20):
                continue
            else:
                actionDict[i]()

        self._saveBytes()

    def randomContent(self, charLimit, size):
        '''
        Returns a list of random bytes

        :param charLimit: upper limit of available bytes. 126 would only allow  "printable ascii" while 255 would allow any character
        :param size: size of list
        :return:
        '''
        return [random.randint(0, charLimit) for _ in range(size)]

    def overlay_append(self, template= PARENT + "/all_pass_pe/template.dll"):
        '''
        Appends to the end of the file. Takes in a template files and adds it 7 times after a wall of zeros

        :param template: Path to template file to be appended Default value is the folder of all 408 system PE files
        :return:
        '''

        to_be_appended = self.format2ByteArray(template)
        zerowall = self.format2ByteArray([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])

        # append zero_walled once
        self.bytez = self.bytez + zerowall + to_be_appended[2:] # drop MZ
        
        for i in range (2):
            self.bytez = self.bytez + to_be_appended[2:] # drop MZ
        self._saveBytes()
        return self.bytez

    def imports_append(self, rand = True, seed=None, lib = "KERNEL32.dll", func = ""):
        '''
        Adds an import to PE file

        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param lib: Library name
        :param func: Function name withing that library
        :return:
        '''
        # add (unused) imports
        binary = self.binary

        # Rigs function to only add from Kernel32.dll
        lib = "KERNEL32.dll"

        if rand:
            # draw a library at random
            #Obsolete until determined otherwise. DO NOT USE
            random.seed(seed)
            # libname = random.choice(list(COMMON_IMPORTS.keys()))

            # Rigs function to only add from Kernel32.dll
            libname = "KERNEL32.dll" 
            funcname = random.choice(list(COMMON_IMPORTS[libname]))
        else:
            try:
                #Makes sure that prgram is picking from list of approved Libraries and functions
                libname = list(COMMON_IMPORTS.keys())[list(COMMON_IMPORTS.keys()).index(lib)]
                funcname = list(COMMON_IMPORTS[libname])[list(COMMON_IMPORTS[libname]).index(func)]
            except:
                funcname = None
                print("Fucntion not in Kernell32.dll, skipping")

        print("Adding", funcname, "Function of Library", libname)

        # find this lib in the imports, if it exists
        lib = None
        for im in binary.imports:
            if im.name.lower() == libname.lower():
                lib = im
                break

        # add a new library if not already in PE file
        if lib is None:
            lib = binary.add_library(libname)

        # get current function names for selected library
        names = set([e.name for e in lib.entries])
        if not funcname is None and not funcname in names:
            lib.add_entry(funcname)

        #Only rebuilds library if function is added
        self.bytez = self.__saveBinary(binary, imports= not funcname is None and not funcname in names)

        return self.bytez


    # def exports_append(self,rand = True, seed=None):
    # TODO: when LIEF has a way to create this
    #     random.seed(seed)
    #     binary = lief.PE.parse( self.bytez )

    #     if not binary.has_exports:
    #         return self.bytez
    #         # TO DO: add a lief.PE.DATA_DIRECTORY.EXPORT_TABLE to the data directory

    #     # find the data directory
    #     for i,e in enumerate(binary.data_directories):
    #         if e.type == lief.PE.DATA_DIRECTORY.EXPORT_TABLE:
    #             break

    # def exports_reorder(self,rand = True, seed=None):
    #   # reorder exports
    #   pass

    def section_rename(self, rand = True, seed=None, sectionIndex = 0, newName = ""):
        '''
        Renames a section

        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param sectionIndex: Index of target section in the section list
        :param newName: New name of section
        :return:
        '''
        # rename a random section
        binary = self.binary

        if rand:
            random.seed(seed)
            targeted_section = random.choice(binary.sections)
            targeted_section.name = random.choice(COMMON_SECTION_NAMES)[
                                    :7]  # current version of lief not allowing 8 chars?
        else:
            targeted_section = binary.sections[sectionIndex]
            targeted_section.name = newName[:7]

        self.bytez = self.__saveBinary(binary)

        return self.bytez

    def section_add(self, rand = True, seed=None, sectionName = "", sectionType = 1, sectionContent = ""):
        '''
        Adds a new section with preexisting content already present.
        Section size is determined by said content and cannot be changed once added

        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param sectionName: Name for new Section
        :param sectionType: Index of new section's type
        :param sectionContent: Content of new Section
        :return:
        '''
        binary = self.binary

        if rand:
            random.seed(seed)
            new_section = lief.PE.Section(
                "".join(chr(random.randrange(ord('.'), ord('z'))) for _ in range(6)))

            # fill with random content
            new_section.content = self.randomContent(charLimit=random.randrange(256),
                                                     size=self.__random_length())
        else:
            new_section = lief.PE.Section(sectionName[:8])
            new_section.content = self.format2Int(sectionContent)

        # print("Adding new Section", new_section.name)
            # new_section.virtual_address = max(
        #     [s.virtual_address + s.size for s in binary.sections])
        # add a new empty section

        if rand or sectionType < 0:
            binary.add_section(new_section,
                               random.choice(SECTION_TYPES))
        else:
            binary.add_section(new_section, SECTION_TYPES[sectionType])

        # binary.add_section(new_section, lief.PE.SECTION_TYPES.DATA)

        self.bytez = self.__saveBinary(binary)
        return self.bytez

    def section_append(self, rand = False, seed=None, template = PARENT + "/all_pass_pe/gdiPlus_data.dll"): #BREAKS FUNCTIONALITY
        '''
        Add content to a pre-existing section's content

        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param newContent: New content to be added
        :return:
        '''
        # append to a section (changes size and entropy)
        binary = self.binary

        for section in binary.sections:
            if rand:
                random.seed(seed)
                targeted_section = section
                L = self.__random_length()
                available_size = targeted_section.size - len(targeted_section.content)
                print("Available Size Detected", available_size, "in section", section.name)
                if L > available_size:
                    L = available_size

                upper = random.randrange(256)
                targeted_section.content = targeted_section.content + \
                                           self.randomContent(charLimit=upper, size=L)
            else:
                offLimitSections = ['.text', '.rdata', ".data", ".pdata", ".rsrc", ".reloc"]
                if section.name.lower() not in offLimitSections:
                    targeted_section = section
                    available_size = targeted_section.size - len(targeted_section.content)
                    print("Available Size Detected", available_size) # available size is zero since it is already filled with zero bytes
                    with open(template,"r+b") as f:
                        to_be_appended = bytearray(f.read())
                    #targeted_section.content = to_be_appended[:len(targeted_section.content)]
                    content = []
                    for i in range (8): # 8 times of template size (mset7tk.dll)
                        content.extend(list(to_be_appended[2:])) # start from 2 to drop mz
                    targeted_section.content = content

        self.bytez = self.__saveBinary(binary)
        return self.bytez

    # def section_reorder(self,param,rand = True, seed=None):
    #   # reorder directory of sections
    #   pass

    # def create_new_entry(self, rand = True, seed=None):
    #     # create a new section with jump to old entry point, and change entry point
    #     # DRAFT: this may have a few technical issues with it (not accounting for relocations), but is a proof of concept for functionality
    #     random.seed(seed)
    #
    #     binary = lief.PE.parse(BUILDPATH + self.fname)
    #
    #     # get entry point
    #     entry_point = binary.optional_header.addressof_entrypoint
    #
    #     # get name of section
    #     entryname = binary.section_from_rva(entry_point).name
    #
    #     # create a new section
    #     new_section = lief.PE.Section(entryname + "".join(chr(random.randrange(
    #         ord('.'), ord('z'))) for _ in range(3)))  # e.g., ".text" + 3 random characters
    #     # push [old_entry_point]; ret
    #     new_section.content = [
    #         0x68] + list(struct.pack("<I", entry_point + 0x10000)) + [0xc3]
    #     new_section.virtual_address = max(
    #         [s.virtual_address + s.size for s in binary.sections])
    #     # TO DO: account for base relocation (this is just a proof of concepts)
    #
    #     # add new section
    #     binary.add_section(new_section, lief.PE.SECTION_TYPES.TEXT)
    #
    #     # redirect entry point
    #     binary.optional_header.addressof_entrypoint = new_section.virtual_address
    #
    #     self.bytez = self.__saveBinary(binary)
    #     return self.bytez

    def upx_pack(self, rand = True, seed=None, cLevel = 1, cExports = 0, cIcons = 0, cResources = 0, cSR = 0):
        '''
        Pack with UPX. Require download

        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param cLevel: Compression Level
        :param cExports: Compress Export format
        :param cIcons: Compress Icon format
        :param cResources: Compress Resource format
        :param cSR: Strip Reloc format
        :return:
        '''
        # tested with UPX 3.91
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        # dump bytez to a temporary file
        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        options = ['--force', '--overlay=copy']
        if rand:
            random.seed(seed)
            compression_level = random.randint(1, 9)
        else:
            compression_level = cLevel
        options += ['-{}'.format(compression_level)]
        # --exact
        # compression levels -1 to -9
        # --overlay=copy [default]

        # optional things:
        # --compress-exports=0/1
        # --compress-icons=0/1/2/3
        # --compress-resources=0/1
        # --strip-relocs=0/1

        if rand:
            random.seed(seed)
            options += ['--compress-exports={}'.format(random.randint(0, 1))]
            options += ['--compress-icons={}'.format(random.randint(0, 3))]
            options += ['--compress-resources={}'.format(random.randint(0, 1))]
            options += ['--strip-relocs={}'.format(random.randint(0, 1))]
        else:
            options += ['--compress-exports={}'.format(cExports)]
            options += ['--compress-icons={}'.format(cIcons)]
            options += ['--compress-resources={}'.format(cResources)]
            options += ['--strip-relocs={}'.format(cSR)]

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ["/".join(os.path.realpath(__file__).replace("\\", "/").split("/")[:-1]) + '/UPX/upx'] + options + [tmpfilename, '-o', tmpfilename + '_packed'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # successfully packed

            with open(tmpfilename + '_packed', 'rb') as infile:
                self.bytez = infile.read()

            os.unlink(tmpfilename + '_packed')

        return self.bytez

    def upx_unpack(self):
        '''
        Unpacks a file using UPX. Require download

        :return:
        '''
        # dump bytez to a temporary file
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ["/".join(os.path.realpath(__file__).replace("\\", "/").split("/")[:-1]) + '/UPX/upx', tmpfilename, '-d', '-o', tmpfilename + '_unpacked'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # sucessfully unpacked
            with open(tmpfilename + '_unpacked', 'rb') as result:
                self.bytez = result.read()

            os.unlink(tmpfilename + '_unpacked')

        return self.bytez

    def remove_signature(self):
        '''
        Unlinks signature from data directory. Data for debug is still present in PE file

        :return:
        '''
        binary = self.binary

        if binary.has_signature:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.CERTIFICATE_TABLE:
                    break
            if e.type == lief.PE.DATA_DIRECTORY.CERTIFICATE_TABLE:
                # remove signature from certificate table
                e.rva = 0
                e.size = 0
                self.bytez = self.__saveBinary(binary)
                return self.bytez
        # if no signature found, self.bytez is unmodified
        return self.bytez

    def remove_debug(self):
        '''
        Unlinks Debug from data directory. Data for debug is still present in PE file

        :return:
        '''
        binary = self.binary

        if binary.has_debug:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    break
            if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                # remove signature from certificate table
                e.rva = 0
                e.size = 0
                self.bytez = self.__saveBinary(binary)
                return self.bytez
        # if no signature found, self.bytez is unmodified
        return self.bytez

    def break_optional_header_checksum(self):
        '''
        Sets Checksum value in the Optional Header to 0

        :return:
        '''
        binary = self.binary
        binary.optional_header.checksum = 0
        self.bytez = self.__saveBinary(binary)
        return self.bytez

    def getBinary(self):
        '''
        :return: Current Binary
        '''
        return self.binary

    def getBuildpath(self):
        '''
        :return: Current Buildpath
        '''
        return BUILDPATH + self.fname

    def changeTDS(self, newTime = 1488320383):
        '''
        Sets Time Date Stamp to a custom ammount. TDS is the ammount of seconds since January 1 1970 00:00:00 UTC

        :param newTime: New amount for Time Datae Stamp
        :return:
        '''
        binary = self.binary
        binary.header.time_date_stamps = newTime
        self.bytez = self.__saveBinary(binary)
        return self.bytez

    def save(self):
        '''
        External function for _saveBytes(). For testing purposes only

        :return:
        '''
        self._saveBytes()

    def format2Int(self, data):
        '''
        Converts ANYTHING into a list of integers.

        :param data: Inpput data. Can be string, filepath, list of int, or bytes
        :return:
        '''
        if type(data) == list and \
                type(data[0]) == int and \
                type(data[-1]) == int and \
                type(random.choice(data[1:-2])) == int: #Checks if input is already a list of integers
            return data
        elif type(data) == str: #Checks if input is a string variable
            try:
                with open(data, 'r') as f: #Checks if input is a filepath to a .txt file
                    return [ord(c) for c in f.read()]
            except:
                try:
                    with open(data, 'rb') as f: #Checks if input is a filepath to a binary file
                        return [c for c in f.read()]
                except: #Converts string directly to list of integers
                    return [ord(c) for c in data]
        elif type(data) == bytes or type(data) == bytearray: #Checks if input is a bytes or bytearray variable
            return [c for c in data]
        else: #Be sad :(
            print("Unrecognized format. Please use string, filepath, list of int, or bytes. Returning None")
            return None

    def format2Bytes(self, data):
        '''
        Converts ANYTHING into a bytes variable.

        :param data: Inpput data. Can be string, filepath, list of int, or bytes
        :return:
        '''

        return bytes(self.format2Int(data))

    def format2ByteArray(self, data):
        '''
        Converts ANYTHING into a bytearray variable.

        :param data: Inpput data. Can be string, filepath, list of int, or bytes
        :return:
        '''

        return bytearray(self.format2Bytes(data))

    def getSection(self):
        binary = self.binary

        try:
            return [x for x in binary.sections if x.name == ".text"][0].content
        except:
            return [x for x in binary.sections if x.name == "UPX1"][0].content
##############################
