# TODO:
# * modify exports using lief
# * zero out rich header (if it exists) --> requires updating OptionalHeader's checksum ("Rich Header" only in Microsoft-produced executables)
# * tinker with resources: https://lief.quarkslab.com/doc/tutorials/07_pe_resource.html

import lief  # pip install https://github.com/lief-project/LIEF/releases/download/0.7.0/linux_lief-0.7.0_py3.6.tar.gz
import json
import os
import sys
import array
import struct  # byte manipulations
import random
import tempfile
import subprocess
import functools
import signal
import multiprocessing

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, 'small_dll_imports.json'), 'r'))

SECTION_TYPES = [
                           lief.PE.SECTION_TYPES.BSS,
                           lief.PE.SECTION_TYPES.DATA,
                           lief.PE.SECTION_TYPES.EXPORT,
                           lief.PE.SECTION_TYPES.IDATA,
                           lief.PE.SECTION_TYPES.RELOCATION,
                           lief.PE.SECTION_TYPES.RESOURCE,
                           lief.PE.SECTION_TYPES.TEXT,
                           lief.PE.SECTION_TYPES.TLS_,
                           lief.PE.SECTION_TYPES.UNKNOWN
                        ]
PARENT = "/".join(os.path.realpath(__file__).split("/")[:-2])
BUILDPATH = PARENT + "/build/"


class MalwareManipulator(object):
#     def __init__(self, bytez):
#         self.bytez = bytez
#         self.min_append_log2 = 5
#         self.max_append_log2 = 8
        
    def __init__(self, filename = "", index = 0):
        self.fname = filename.split('/')[-1].split('.')[0]
        #print('>>>>>>',self.fname)
        self.binary = lief.PE.parse(filename)
        with open(filename,"r+b") as f:
            self.bytez = bytearray(f.read())
        self.min_append_log2 = 5
        self.max_append_log2 = 8   

    def __random_length(self):
        return 2**random.randint(self.min_append_log2, self.max_append_log2)

    def __saveBinary(self, binary, dos_stub=False, imports=False, overlay=False, relocations=False, resources=False, tls=False):
        '''
        Originally meant to convert binaries back to bytes, but the original process didnt work
        Added builder.build() so that it actually saves the binary into a file that LIEF can parse

        :param binary: New Binary with changes
        :param dos_stub: PE file options
        :param imports: PE file options
        :param overlay: PE file options
        :param relocations: PE file options
        :param resources: PE file options
        :param tls: PE file options
        :return: New Bytes with changes recorded.

        Also saves binary into a file specifies by the buildpath
        '''

        # write the file back as bytez
        builder = lief.PE.Builder(binary)
        builder.build_dos_stub(dos_stub) # rebuild DOS stub

        builder.build_imports(imports) # rebuild IAT in another section
        builder.patch_imports(imports) # patch original import table with trampolines to new import table

        builder.build_overlay(overlay) # rebuild overlay
        builder.build_relocations(relocations) # rebuild relocation table in another section
        builder.build_resources(resources) # rebuild resources in another section
        builder.build_tls(tls) # rebuilt TLS object in another section

        builder.build() # perform the build process

        # builder.write(BUILDPATH + self.fname)

        # try:
        #     self._saveBytes()
        # except:
        #     pass
        return array.array('B', builder.get_build()).tobytes()
    
    def _saveBytes(self):
        bytes_ = self.bytez
        with open(BUILDPATH + self.fname, 'w+b') as file:
            file.write(bytes_)

    def overlay_append_random(self, seed=None):
        random.seed(seed)
        L = self.__random_length()
        # choose the upper bound for a uniform distribution in [0,upper]
        upper = random.randrange(256)
        # upper chooses the upper bound on uniform distribution:
        # upper=0 would append with all 0s
        # upper=126 would append with "printable ascii"
        # upper=255 would append with any character
        return self.bytez + bytes([random.randint(0, upper) for _ in range(L)])
    
    def overlay_append(self, rand = True, seed=None, template = PARENT + "template/mset7tk.dll"):
        '''
        Appends MSEC twice to the end of the file with zero wall. Depending on what exactly we want, this will need some editing
        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param template: Path to template file to be appended Default value is the folder of all 408 system PE files
        :return:
        '''
        with open(template,"r+b") as f:
            to_be_appended = bytearray(f.read())
        
        zerowall = bytearray([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])

        # append zero_walled once
        self.bytez = self.bytez + zerowall + to_be_appended[2:] # drop MZ
        
        for i in range (1):
            self.bytez = self.bytez + to_be_appended[2:] # drop MZ
        self._saveBytes()
        return self.bytez

    def imports_append(self, rand = True, seed=None, lib = "KERNEL32.dll", func = ""):
            '''
            Adds an import to PE file
            :param rand: Whether or not the process is randomized
            :param seed: Seed for randomization
            :param lib: Library name
            :param func: Function name withing that library
            :return:
            '''
            # add (unused) imports
            binary = self.binary
    
            # Rigs function to only add from Kernel32.dll
            lib = "KERNEL32.dll"
    
            if rand:
                # draw a library at random
                #Obsolete until determined otherwise. DO NOT USE
                random.seed(seed)
                libname = random.choice(list(COMMON_IMPORTS.keys()))
                libname = "KERNEL32.dll" 
                funcname = random.choice(list(COMMON_IMPORTS[libname]))
            else:
                try:
                    #Makes sure that prgram is picking from list of approved Libraries and functions
                    libname = list(COMMON_IMPORTS.keys())[list(COMMON_IMPORTS.keys()).index(lib)]
                    funcname = list(COMMON_IMPORTS[libname])[list(COMMON_IMPORTS[libname]).index(func)]
                except:
                    funcname = None
                    print("Fucntion not in Kernell32.dll, skipping")
    
            print("Adding", funcname, "Function of Library", libname)
    
            # find this lib in the imports, if it exists
            lib = None
            for im in binary.imports:
                if im.name.lower() == libname.lower():
                    lib = im
                    break
    
            # add a new library if not already in PE file
            if lib is None:
                lib = binary.add_library(libname)
    
            # get current function names for selected library
            names = set([e.name for e in lib.entries])
            if not funcname is None and not funcname in names:
                lib.add_entry(funcname)
    
            #Only rebuilds library if function is added
            self.bytez = self.__saveBinary(binary, imports= not funcname is None and not funcname in names)
    
            return self.bytez

    # def exports_append(self,seed=None):
    # TODO: when LIEF has a way to create this
    #     random.seed(seed)
    #     binary = lief.PE.parse( self.bytez )

    #     if not binary.has_exports:
    #         return self.bytez
    #         # TO DO: add a lief.PE.DATA_DIRECTORY.EXPORT_TABLE to the data directory

    #     # find the data directory
    #     for i,e in enumerate(binary.data_directories):
    #         if e.type == lief.PE.DATA_DIRECTORY.EXPORT_TABLE:
    #             break

    # def exports_reorder(self,seed=None):
    #   # reorder exports
    #   pass

    def section_rename(self, rand = True, seed=None, sectionIndex = 0, newName = ""):
        '''
        Renames a section
        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param sectionIndex: Index of target section in the section list
        :param newName: New name of section
        :return:
        '''
        # rename a random section
        binary = self.binary

        if rand:
            random.seed(seed)
            targeted_section = random.choice(binary.sections)
            targeted_section.name = random.choice(COMMON_SECTION_NAMES)[
                                    :7]  # current version of lief not allowing 8 chars?
        else:
            targeted_section = binary.sections[sectionIndex]
            targeted_section.name = newName[:7]

        self.bytez = self.__saveBinary(binary)

        return self.bytez


    def section_add(self, rand = True, seed=None, sectionName = "", sectionType = -1, sectionContent = []):
        '''
        Adds a new section
        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param sectionName: Name for new Section
        :param sectionType: Index of new section's type
        :param sectionContent: Content of new Section
        :return:
        '''
        binary = self.binary

        if rand:
            random.seed(seed)
            new_section = lief.PE.Section(
                "".join(chr(random.randrange(ord('.'), ord('z'))) for _ in range(6)))

            # fill with random content
            new_section.content = self.randomContent(charLimit=random.randrange(256),
                                                     size=self.__random_length())
        else:
            new_section = lief.PE.Section(sectionName[:8])
            new_section.content = sectionContent

        new_section.virtual_address = max(
            [s.virtual_address + s.size for s in binary.sections])
        # add a new empty section

        if rand or sectionType < 0:
            binary.add_section(new_section,
                               random.choice(SECTION_TYPES))
        else:
            binary.add_section(new_section, SECTION_TYPES[sectionType])

        self.bytez = self.__saveBinary(binary)
        return self.bytez

    def section_append(self, rand = False, seed=None, template = PARENT + "/all_pass_pe/gdiPlus_data.dll"):
        '''
        Add content to a pre-existing section;s content
        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param newContent: New content to be added
        :return:
        '''
        # append to a section (changes size and entropy)
        binary = self.binary

        for section in binary.sections:
            if rand:
                random.seed(seed)
                targeted_section = section
                L = self.__random_length()
                available_size = targeted_section.size - len(targeted_section.content)
                print("Available Size Detected", available_size, "in section", section.name)
                if L > available_size:
                    L = available_size

                upper = random.randrange(256)
                targeted_section.content = targeted_section.content + \
                                           self.randomContent(charLimit=upper, size=L)
            else:
                if section.name.lower() == '.app':
                    targeted_section = section
                    available_size = targeted_section.size - len(targeted_section.content)
                    print("Available Size Detected", available_size) # available size is zero since it is already filled with zero bytes
                    with open(template,"r+b") as f:
                        to_be_appended = bytearray(f.read())
                    #targeted_section.content = to_be_appended[:len(targeted_section.content)]
                    content = []
                    for i in range (8): # 8 times of template size (mset7tk.dll)
                        content.extend(list(to_be_appended[2:])) # start from 2 to drop mz
                    targeted_section.content = content

        self.bytez = self.__saveBinary(binary)
        return self.bytez

    # def section_reorder(self,param,seed=None):
    #   # reorder directory of sections
    #   pass

    def upx_pack(self, rand = True, seed=None, cLevel = 1, cExports = 0, cIcons = 0, cResources = 0, cSR = 0):
        '''
        Pack with UPX. Require download
        :param rand: Whether or not the process is randomized
        :param seed: Seed for randomization
        :param cLevel: Compression Level
        :param cExports: Compress Export format
        :param cIcons: Compress Icon format
        :param cResources: Compress Resource format
        :param cSR: Strip Reloc format
        :return:
        '''
        # tested with UPX 3.91
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        # dump bytez to a temporary file
        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        options = ['--force', '--overlay=copy']
        if rand:
            random.seed(seed)
            compression_level = random.randint(1, 9)
        else:
            compression_level = cLevel
        options += ['-{}'.format(compression_level)]
        # --exact
        # compression levels -1 to -9
        # --overlay=copy [default]

        # optional things:
        # --compress-exports=0/1
        # --compress-icons=0/1/2/3
        # --compress-resources=0/1
        # --strip-relocs=0/1

        if rand:
            random.seed(seed)
            options += ['--compress-exports={}'.format(random.randint(0, 1))]
            options += ['--compress-icons={}'.format(random.randint(0, 3))]
            options += ['--compress-resources={}'.format(random.randint(0, 1))]
            options += ['--strip-relocs={}'.format(random.randint(0, 1))]
        else:
            options += ['--compress-exports={}'.format(cExports)]
            options += ['--compress-icons={}'.format(cIcons)]
            options += ['--compress-resources={}'.format(cResources)]
            options += ['--strip-relocs={}'.format(cSR)]

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ["/".join(os.path.realpath(__file__).split("/")[:-1]) + '/UPX/upx'] + options + [tmpfilename, '-o', tmpfilename + '_packed'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # successfully packed

            with open(tmpfilename + '_packed', 'rb') as infile:
                self.bytez = infile.read()

            os.unlink(tmpfilename + '_packed')

        return self.bytez

    def upx_unpack(self):
        '''
        Unpacks a file using UPX. Require download
        :return:
        '''
        # dump bytez to a temporary file
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ["/".join(os.path.realpath(__file__).split("/")[:-1]) + '/UPX/upx', tmpfilename, '-d', '-o', tmpfilename + '_unpacked'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # sucessfully unpacked
            with open(tmpfilename + '_unpacked', 'rb') as result:
                self.bytez = result.read()

            os.unlink(tmpfilename + '_unpacked')

        return self.bytez

    def remove_signature(self):
        '''
        Remove the signature of the file
        :return:
        '''
        binary = self.binary

        if binary.has_signature:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.CERTIFICATE_TABLE:
                    break
            if e.type == lief.PE.DATA_DIRECTORY.CERTIFICATE_TABLE:
                # remove signature from certificate table
                e.rva = 0
                e.size = 0
                self.bytez = self.__saveBinary(binary)
                return self.bytez
        # if no signature found, self.bytez is unmodified
        return self.bytez

    def remove_debug(self):
        '''
        Remove the debug of the file
        :return:
        '''
        binary = self.binary

        if binary.has_debug:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    break
            if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                # remove signature from certificate table
                e.rva = 0
                e.size = 0
                self.bytez = self.__saveBinary(binary)
                return self.bytez
        # if no signature found, self.bytez is unmodified
        return self.bytez

    def break_optional_header_checksum(self):
        binary = self.binary
        binary.optional_header.checksum = 0
        self.bytez = self.__saveBinary(binary)
        return self.bytez
    
    def changeTDS(self, newTime = 1488320383):
        binary = self.binary
        binary.header.time_date_stamps = newTime
        self.bytez = self.__saveBinary(binary)
        return self.bytez


##############################
def identity(bytez, seed=None):
    return bytez


######################
# explicitly list so that these may be used externally
ACTION_TABLE = {
    # 'do_nothing': identity,
    'overlay_append': 'overlay_append',
    #'imports_append': 'imports_append',
    #'section_rename': 'section_rename',
    #'section_add': 'section_add',
    #'section_append': 'section_append',
    #'create_new_entry': 'create_new_entry',
    #'remove_signature': 'remove_signature',
    #'remove_debug': 'remove_debug',
    'upx_pack': 'upx_pack',
    #'upx_unpack': 'upx_unpack',
    #'break_optional_header_checksum': 'break_optional_header_checksum',
    #   'modify_exports' : modify_exports,
}

def modify_without_breaking(bytez, actions=[], seed=None):
    for action in actions:

        _action = ACTION_TABLE[action]
        
        _action = MalwareManipulator(bytez).__getattribute__(_action)
        
    bytez=?
    import hashlib
    m = hashlib.sha256()
    m.update( bytez )
    print("new hash: {}".format(m.hexdigest()))
    return bytez

def modify_without_breaking_0(bytez, actions=[], seed=None):
    for action in actions:

        _action = ACTION_TABLE[action]

        # we run manipulation in a child process to shelter
        # our malware model from rare parsing errors in LIEF that
        # may segfault or timeout
        def helper(_action,shared_list):
            # TODO: LIEF is chatty. redirect stdout and stderr to /dev/null

            # for this process, change segfault of the child process
            # to a RuntimeEror
            def sig_handler(signum, frame):
                raise RuntimeError
            signal.signal(signal.SIGSEGV, sig_handler)

            bytez = array.array('B', shared_list[:]).tobytes()
            # TODO: LIEF is chatty. redirect output to /dev/null
            if type(_action) is str:
                _action = MalwareManipulator(bytez).__getattribute__(_action)
            else:
                _action = functools.partial( _action, bytez )

            # redirect standard out only in this queue
            try:
                shared_list[:] = _action(seed) 
            except (RuntimeError,UnicodeDecodeError,TypeError,lief.not_found) as e:
                # some exceptions that have yet to be handled by public release of LIEF
                print("==== exception in child process ===")
                print(e)
                # shared_bytez remains unchanged                


        # communicate with the subprocess through a shared list
        # can't use multiprocessing.Array since the subprocess may need to
        # change the size
        manager = multiprocessing.Manager()
        shared_list = manager.list() 
        shared_list[:] = bytez # copy bytez to shared array
        # define process
        p = multiprocessing.Process( target=helper, args=(_action,shared_list) ) 
        p.start() # start the process
        try:
            p.join(5) # allow this to take up to 5 seconds...
        except multiprocessing.TimeoutError: # ..then become petulant
            print('==== timeouterror ')
            p.terminate()

        bytez = array.array('B', shared_list[:]).tobytes() # copy result from child process

    import hashlib
    m = hashlib.sha256()
    m.update( bytez )
    print("new hash: {}".format(m.hexdigest()))
    return bytez

def test(bytez):
    binary = lief.PE.parse(bytez)

    print('overlay_append')
    manip = MalwareManipulator(bytez)        
    bytez2 = manip.overlay_append(bytez)
    binary2 = lief.PE.parse(bytez2)
    assert len(binary.overlay) != len(binary2.overlay), "modification failed"

    # SUCCEEDS, but note that lief builder also adds a new ".l1" section for each patch of the imports
    print('imports_append')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.imports_append(bytez)
    binary2 = lief.PE.parse(bytez2)
    set1 = set(binary.imported_functions)
    set2 = set(binary2.imported_functions)
    diff = set2.difference(set1)
    print(list(diff))
    assert len(binary.imported_functions) != len(binary2.imported_functions), "no new imported functions"

    # SUCCEEDS
    print('section_rename')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.section_rename(bytez)
    binary2 = lief.PE.parse(bytez2)
    oldsections = [s.name for s in binary.sections]
    newsections = [s.name for s in binary2.sections]
    print(oldsections)
    print(newsections)
    assert " ".join(newsections) != " ".join(oldsections), "no modified sections"

    print('section_add')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.section_add(bytez)
    binary2 = lief.PE.parse(bytez2)
    oldsections = [s.name for s in binary.sections]
    newsections = [s.name for s in binary2.sections]
    print(oldsections)
    print(newsections)
    assert len(newsections) != len(oldsections), "no new sections"

    # FAILS if there's insufficient room to add to the section 
    print('section_append')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.section_append(bytez)
    binary2 = lief.PE.parse(bytez2)
    oldsections = [len(s.content) for s in binary.sections]
    newsections = [len(s.content) for s in binary2.sections]
    print(oldsections)
    print(newsections)
    assert sum(newsections) != sum(oldsections), "no appended section"

    print('create_new_entry') # note: also adds a new section
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.create_new_entry(bytez)
    binary2 = lief.PE.parse(bytez2)
    print(binary.entrypoint)
    print(binary2.entrypoint)
    assert binary.entrypoint != binary2.entrypoint, "no new entry point"

    print('remove_signature')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.remove_signature(bytez)
    binary2 = lief.PE.parse(bytez2)
    if binary.has_signature:
        assert binary2.has_signature == False, "failed to remove signature"

    print('remove_debug')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.remove_debug(bytez)
    binary2 = lief.PE.parse(bytez2)
    if binary.has_debug:
        assert binary2.has_debug == False, "failed to remove debug"

    print('break_optional_header_checksum')
    manip = MalwareManipulator(bytez)    
    bytez2 = manip.break_optional_header_checksum(bytez)
    binary2 = lief.PE.parse(bytez2)
    assert binary2.optional_header.checksum == 0, "checksum not zero :("


