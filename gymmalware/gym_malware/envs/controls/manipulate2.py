# TODO:
# * modify exports using lief
# * zero out rich header (if it exists) --> requires updating OptionalHeader's checksum ("Rich Header" only in Microsoft-produced executables)
# * tinker with resources: https://lief.quarkslab.com/doc/tutorials/07_pe_resource.html
import lief  # pip install https://github.com/lief-project/LIEF/releases/download/0.7.0/linux_lief-0.7.0_py3.6.tar.gz
import json
import os
import sys
import array
import struct  # byte manipulations
import random
import tempfile
import subprocess
import functools
import signal
import threading
import time
import torch
from tokenizers import ByteLevelBPETokenizer
from transformers import GPT2Config
from transformers import GPT2TokenizerFast
from transformers import GPT2LMHeadModel
from transformers import LineByLineTextDataset
from transformers import DataCollatorForLanguageModeling
from transformers import Trainer, TrainingArguments
# from transformers import pipeline
from numpy import arange

import importlib.util
spec = importlib.util.spec_from_file_location("transformers.pipelines2", "/home/eb/transformers/src/transformers/pipelines2.py")
foo = importlib.util.module_from_spec(spec)
spec.loader.exec_module(foo)


sys.path.insert(1, '/home/eb/eclipse-workspace/PGAR_cust_gen_load_emb/gymmalware/gym_malware/envs/controls')
sys.path.insert(1, '/home/eb/transformers/src/transformers')

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

PARENT = "/".join(os.path.realpath(__file__).split("/")[:-2])
SAMPLES_PATH = PARENT + "/utils/samples"


class MalwareManipulator(object):
    def __init__(self, bytez):
        self.bytez = bytez
        self.min_append_log2 = 5
        self.max_append_log2 = 8
        
    def __init__(self, sha256 = ""):
        filename = SAMPLES_PATH + "/" + sha256
        self.fname = filename.split('/')[-1].split('.')[0]
        self.binary = lief.PE.parse(filename)
        with open(filename,"r+b") as f:
            self.bytez = bytearray(f.read())
        self.min_append_log2 = 5
        self.max_append_log2 = 8
        
    def __random_length(self): ## REMEMBER Not random
        return 2**random.randint(self.min_append_log2, self.max_append_log2)

    def _saveBytes(self):
        '''
        Saves Bytez variable to file. ONLY FUNCTION IN CODE TO SAVE TO FILE

        :return:
        '''
        with open(BUILDPATH + self.fname, 'w+b') as file:
            file.write(self.bytez)

    def overlay_append(self):
        '''
        Appends to the end of the file. Takes in a template files and adds it 7 times after a wall of zeros

        :param template: Path to template file to be appended Default value is the folder of all 408 system PE files
        :return:
        '''
        template = self.format2ByteArray("/mset7tk.dll")
        upper = random.randrange(len(template))
        lower = (upper-25) if (upper>25) else 0
        print ("upper ", upper)
        print ("lower", lower)
        to_be_appended = template[lower:upper]
        zerowall = self.format2ByteArray([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])

        # append zero_walled once
        self.bytez = self.bytez + zerowall + to_be_appended[2:] # drop MZ
        
        for i in range (1):
            self.bytez = self.bytez + to_be_appended[2:] # drop MZ
        ### For now, savebytez is commented out. At this stage, we never save! Maybe later
        #self._saveBytes()
        return self.bytez
    
    def overlay_append_random(self, rand = True, seed=None):
        random.seed(seed)
        L = self.__random_length()
        # choose the upper bound for a uniform distribution in [0,upper]
        upper = random.randrange(256)
        # upper chooses the upper bound on uniform distribution:
        # upper=0 would append with all 0s
        # upper=126 would     append with "printable ascii"
        # upper=255 would append with any character
        return self.bytez + bytes([random.randint(0, upper) for _ in range(L)])
    
    def overlay_append_n(self, id, extra_sampled_actions):      
        token = tokens[id]
        token = token.replace('Ä ','')
        ##token = token.zfill(4)
        ## Remember length for malconv was 120. For NonNeg was changed to 500
        generated_hex_str = generator(token, max_length = 300, num_return_sequences=1, do_sample= True, top_k=2, extra_sampled_actions=extra_sampled_actions) ## Not always return 20
        generated_hex_str = generated_hex_str[0]['generated_text']
        ##print ('*******************TOKEN IS: ********: '+ token)
        return self.bytez + self.format2ByteArray(generated_hex_str)
        
    def format2Int(self, data):
        '''
        Converts ANYTHING into a list of integers.

        :param data: Inpput data. Can be string, filepath, list of int, or bytes
        :return:
        '''
        if type(data) == list and \
                type(data[0]) == int and \
                type(data[-1]) == int and \
                type(random.choice(data[1:-2])) == int: #Checks if input is already a list of integers
            return data
        elif type(data) == str: #Checks if input is a string variable
            try:
                with open(data, 'r') as f: #Checks if input is a filepath to a .txt file
                    return [ord(c) for c in f.read()]
            except:
                try:
                    with open(data, 'rb') as f: #Checks if input is a filepath to a binary file
                        return [c for c in f.read()]
                except: #Converts string directly to list of integers
                    return [ord(c) for c in data]
        elif type(data) == bytes or type(data) == bytearray: #Checks if input is a bytes or bytearray variable
            return [c for c in data]
        else: #Be sad :(
            print("Unrecognized format. Please use string, filepath, list of int, or bytes. Returning None")
            return None
    
    def format2Bytes(self, data):
        '''
        Converts ANYTHING into a bytes variable.

        :param data: Inpput data. Can be string, filepath, list of int, or bytes
        :return:
        '''

        return bytes(self.format2Int(data))

    def format2ByteArray(self, data):
        '''
        Converts ANYTHING into a bytearray variable.

        :param data: Inpput data. Can be string, filepath, list of int, or bytes
        :return:
        '''

        return bytearray(self.format2Bytes(data))
    

######################
# explicitly list so that these may be used externally
ACTION_TABLE = {
    ###'overlay_append_random': 'overlay_append_random',
}

## read the tokens from vocab
with open('../model_hex/vocab.json') as vocab:
    tokens = json.load(vocab)
tokens = {v: k for k, v in tokens.items()}

action_ids = arange(len(tokens))

for i_d in action_ids:
    ACTION_TABLE['overlay_append_'+str(i_d)] =  i_d


#### Load GPT2 Generator
tokenizer = GPT2TokenizerFast.from_pretrained("../model_hex")
tokenizer.pad_token_id = '1'
tokenizer.eos_token_id = '1'
generator = foo.pipeline2('text-generation',model='../model_hex', tokenizer=tokenizer)## REMEMBER running on gpu give some cuda error at some point 

def modify_without_breaking(sha256, actions=[], extra_sampled_actions=[], seed=None):
    output = bytearray()
    for action in actions:

        _action = ACTION_TABLE[action]
        mm = MalwareManipulator(sha256)
        #time.sleep(1)

        # we run manipulation in a child process to shelter
        # our malware model from rare parsing errors in LIEF that
        # may segfault or timeout
        def helper(_action,sha256, extra_sampled_actions):
            global bytez
            # redirect standard out only in this queue
            try:
                ##_action = mm.__getattribute__(_action)
                bytez = mm.overlay_append_n(_action, extra_sampled_actions)
            except (RuntimeError,UnicodeDecodeError,TypeError,lief.not_found) as e:
                # some exceptions that have yet to be handled by public release of LIEF
                print("==== exception in child process ===")
                print(e)
                # shared_bytez remains unchanged                

        # communicate with the subprocess through a shared list
        #manager = multiprocessing.Manager()
        #shared_list[:] = bytez # copy bytez to shared array
                
        # define process
        #p = multiprocessing.Process( target=helper, args=(_action,sha256, output) ) 
        #p.start() # start the process
        thread = threading.Thread(target=helper, args=(_action,sha256,extra_sampled_actions,))
        thread.start()
        thread.join()
                    
        output[:] =  bytez

    import hashlib
    m = hashlib.sha256()
    m.update( output )
    print("new hash: {}".format(m.hexdigest()))
    return output

